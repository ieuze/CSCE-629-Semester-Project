import numpy as np
from scipy.optimize import linprog
import itertools
import time # Add for timing

def compute_m_height(G, m):
    """
    Compute the m-height h_m(C) for the code C generated by G using the
    LP formulation from Theorem 1 of the provided paper [Jia24].

    Parameters:
    G (numpy.ndarray): Generator matrix of shape (k, n).
    m (int): Parameter defining the m-height. Should be >= 1.

    Returns:
    float: The m-height h_m(C). Returns np.inf if the max objective value is unbounded.
    """
    k, n = G.shape

    # print(f"  [Verifier] compute_m_height(G.shape=({k},{n}), m={m}) starting...") # Suppress
    start_time = time.time() # Keep timing if needed internally

    if not (1 <= m <= n - 1):
         # The theorem statement assumes m <= n-1.
         # The definition of Γ requires |X|=m-1 and X subset of [n]\\{a,b},
         # so n-2 >= m-1, meaning n-1 >= m.
         # Also m=0 has h0(C)=1 defined separately.
         if m == 0:
             return 1.0
         raise ValueError(f"m must be between 1 and n-1 ({n-1}), but got {m}")

    # Generate Ψ = {-1, 1}^m
    psi_set = list(itertools.product([-1, 1], repeat=m))

    max_z = 0.0 # Initialize the maximum objective value found so far
    lp_count = 0
    first_lp_logged = False # This flag is no longer used if logging is suppressed

    # Iterate through all possible tuples (a, b, X, ψ) in Γ
    all_indices = list(range(n))
    for a in all_indices:
        for b in all_indices:
            if a == b:
                continue

            other_indices = [i for i in all_indices if i != a and i != b]

            # Need at least m-1 indices to choose from for X
            if len(other_indices) < m - 1:
                continue

            for X_tuple in itertools.combinations(other_indices, m - 1):
                X = list(X_tuple) # The set X
                X_set = set(X)
                X_sorted = sorted(X) # x_1, ..., x_{m-1}

                # Y = [n] \ X \ {a, b}
                Y = [i for i in other_indices if i not in X_set]

                for psi in psi_set:
                    # psi = (s_0, s_1, ..., s_{m-1})
                    s0 = psi[0]

                    # --- Set up the Linear Program LP_{a,b,X,ψ} ---
                    # Variables: u_0, ..., u_{k-1} (shape k)
                    # Maximize sum(s_0 * g_{i,a} * u_i)
                    # Equivalent to Minimize sum(-s_0 * g_{i,a} * u_i)
                    c = [-s0 * G[i, a] for i in range(k)]

                    A_ub_list = []
                    b_ub_list = []
                    A_eq_list = []
                    b_eq_list = []

                    # Constraints involving X (indices x_1 to x_{m-1})
                    # Let l correspond to the index in psi (1 to m-1)
                    for l in range(1, m):
                        j = X_sorted[l-1] # This is x_l in the paper's notation
                        sl = psi[l]       # This is s_l

                        # Constraint 1: sum_i (sl * g_{i,j} - s0 * g_{i,a}) * u_i <= 0
                        row1 = [(sl * G[i, j] - s0 * G[i, a]) for i in range(k)]
                        A_ub_list.append(row1)
                        b_ub_list.append(0)

                        # Constraint 2: sum_i (-sl * g_{i,j}) * u_i <= -1
                        row2 = [-sl * G[i, j] for i in range(k)]
                        A_ub_list.append(row2)
                        b_ub_list.append(-1)

                    # Constraint 3: sum_i (g_{i,b} * u_i) = 1
                    row3 = [G[i, b] for i in range(k)]
                    A_eq_list.append(row3)
                    b_eq_list.append(1)

                    # Constraints involving Y
                    for j in Y:
                        # Constraint 4: sum_i (g_{i,j} * u_i) <= 1
                        row4 = [G[i, j] for i in range(k)]
                        A_ub_list.append(row4)
                        b_ub_list.append(1)

                        # Constraint 5: sum_i (-g_{i,j} * u_i) <= 1
                        row5 = [-G[i, j] for i in range(k)]
                        A_ub_list.append(row5)
                        b_ub_list.append(1)

                    # Convert lists to numpy arrays
                    A_ub = np.array(A_ub_list) if A_ub_list else np.empty((0, k))
                    b_ub = np.array(b_ub_list) if b_ub_list else np.empty((0,))
                    A_eq = np.array(A_eq_list) if A_eq_list else np.empty((0, k))
                    b_eq = np.array(b_eq_list) if b_eq_list else np.empty((0,))

                    # Bounds for u_i are (-inf, inf)
                    bounds = [(None, None)] * k

                    # <<< ADDED: Log first LP details >>
                    # if not first_lp_logged:
                    #     print(f"  [Verifier] Solving first LP with: a={a}, b={b}, X={X_sorted}, s0={psi[0]}") # Suppress
                    #     first_lp_logged = True

                    # Solve the LP
                    # Use 'highs' for better performance and reliability
                    result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')

                    # Determine z_{a,b,X,ψ} based on result status
                    z_current = 0.0
                    if result.status == 0: # Optimal solution found
                        z_current = -result.fun # Negate because we minimized
                    elif result.status == 3: # Unbounded
                        z_current = np.inf
                        # print(f"  [Verifier] Found UNBOUNDED LP (inf) at LP #{lp_count} with params a={a}, b={b}, X={X}, psi={psi}") # Suppress
                    elif result.status == 2: # Infeasible
                        z_current = 0.0
                    # Optional: Handle other statuses (e.g., iteration limit, numerical difficulties)
                    # else:
                    #     print(f"Warning: LP solver returned status {result.status} for tuple (a={a}, b={b}, X={X}, psi={psi})")
                    #     z_current = 0.0 # Default to 0 as per paper's infeasible case

                    # Update the maximum z found so far
                    if z_current > max_z:
                         max_z = z_current

                    # If we hit infinity, we know the final result is infinity
                    if max_z == np.inf:
                        # end_time_inf = time.time() # Keep timing if needed internally
                        # print(f"  [Verifier] compute_m_height returning inf after {lp_count} LPs ({end_time_inf - start_time:.2f} sec)") # Suppress
                        return np.inf

                    lp_count += 1

    # end_time = time.time() # Keep timing if needed internally
    # print(f"  [Verifier] compute_m_height finished. max_z={max_z:.4f}. Solved {lp_count} LPs ({end_time - start_time:.2f} sec)") # Suppress
    return max_z

# Example usage:
# Need a valid G and m where 1 <= m <= n-1
# For G = np.array([[1, 1, 0], [0, 1, 1]]), n=3, k=2. We can test m=1 or m=2.
# try:
#     G_test = np.array([[1, 1, 0], [0, 1, 1]])
#     m_test = 1
#     hm = compute_m_height(G_test, m_test)
#     print(f"h_{m_test}(C) = {hm}") # Expected based on manual check or reference?
#
#     m_test = 2
#     hm = compute_m_height(G_test, m_test)
#     print(f"h_{m_test}(C) = {hm}") # Expected based on manual check or reference?
# except ValueError as e:
#     print(e)
# except ImportError:
#     print("Please install scipy: pip install scipy")

# Example from the original file (corrected m)
# G = np.array([[1, 0, 0, 1], [0, 1, 0, -1], [0, 0, 1, 2]])  # n=4, k=3
# m = 1 # n-k = 1, so only m=1 is allowed by the previous code's assert, but n-1=3 here.
# try:
#     # Testing with m=1 according to Theorem 1
#     hm = compute_m_height(G, 1)
#     print(f"Minimal m-height (m=1) using Theorem 1: {hm}")
#     # Testing with m=2 according to Theorem 1
#     hm = compute_m_height(G, 2)
#     print(f"Minimal m-height (m=2) using Theorem 1: {hm}")
#     # Testing with m=3 according to Theorem 1
#     hm = compute_m_height(G, 3)
#     print(f"Minimal m-height (m=3) using Theorem 1: {hm}")
# except ValueError as e:
#      print(e)
# except ImportError:
#      print("Please install scipy: pip install scipy")