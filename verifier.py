import numpy as np
from scipy.optimize import linprog

def compute_m_height(G, m):
    """
    Compute the minimal m-height for the analog code generated by G using LP.

    Parameters:
    G (numpy.ndarray): Generator matrix of shape (k, n).
    m (int): Parameter defining the m-height.

    Returns:
    float: The minimal m-height.
    """

    k, n = G.shape
    assert m <= n - k, "m should be less than or equal to n - k"

    # Number of codewords to consider
    num_codewords = 2 ** k

    # Generate all possible binary message vectors
    messages = np.array([list(format(i, f'0{k}b')) for i in range(num_codewords)], dtype=int)

    # Generate all codewords
    codewords = np.dot(messages, G)  # Shape: (num_codewords, n)

    # Initialize list to store m-heights of all codewords
    m_heights = []

    for codeword in codewords:
        # Get the indices that would sort the codeword by absolute value in descending order
        sorted_indices = np.argsort(-np.abs(codeword))

        # Select the first m indices
        m_indices = sorted_indices[:m]

        # Extract the m largest absolute values
        m_largest_values = codeword[m_indices]

        # Set up the LP problem to minimize the maximum ratio
        # Objective function: minimize t
        c = np.zeros(m + 1)
        c[-1] = 1  # Coefficient for t

        # Constraints: |x_i| <= t * |x_j| for all i in m_indices, j in remaining indices
        A = []
        b = []

        for i in m_indices:
            for j in range(n):
                if j not in m_indices:
                    constraint = np.zeros(m + 1)
                    constraint[m_indices.tolist().index(i)] = 1  # x_i coefficient
                    constraint[-1] = -np.abs(codeword[j])  # -t * |x_j|
                    A.append(constraint)
                    b.append(0)

        A = np.array(A)
        b = np.array(b)

        # Bounds for variables: x_i are free, t >= 0
        x_bounds = [(None, None)] * m
        t_bounds = [(0, None)]
        bounds = x_bounds + t_bounds

        # Solve the LP problem
        result = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')

        if result.success:
            m_heights.append(result.x[-1])  # The value of t
        else:
            raise ValueError("LP solver failed to find a solution.")

    # The minimal m-height is the minimum of all computed m-heights
    minimal_m_height = min(m_heights)
    return minimal_m_height

# Example usage:
# G = np.array([[1, 0, 0, 1], [0, 1, 0, -1], [0, 0, 1, 2]])  # Example generator matrix
# m = 2
# minimal_m_height = compute_m_height(G, m)
# print("Minimal m-height:", minimal_m_height)
