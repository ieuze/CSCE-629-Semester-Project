import numpy as np
import itertools
from scipy.optimize import linprog

DEBUG = False          # Enable detailed debug output
CHECK_ALL_PAIRS = True  # Set to True to loop over all (a,b) pairs

def solve_lp_for_tuple(G, a, b, X, psi):
    """
    Solve the LP for a given tuple (a, b, X, psi) based on the project formulation.
    This version uses two inequality constraints to enforce the normalization constraint.
    """
    k, n = G.shape
    m = len(psi)
    
    sorted_X = sorted(X)
    if len(sorted_X) != m - 1:
        raise ValueError("Size of X must be m-1.")
    
    # Y: remaining columns
    Y = sorted(set(range(n)) - {a, b} - set(sorted_X))
    
    # Quasi-sorted permutation: tau = [a] + sorted_X + [b] + sorted(Y)
    tau = [a] + sorted_X + [b] + sorted(Y)
    tau_inv = {col: pos for pos, col in enumerate(tau)}
    
    num_vars = k
    # Objective: maximize sum_i (psi[0] * G[i,a] * u_i) --> minimize negative objective
    c = - (psi[0] * G[:, a])
    
    A_ub = []
    b_ub = []
    
    # Constraints for each j in X
    for j in sorted_X:
        r = tau_inv[j]  # should be between 1 and m-1
        A_ub.append(psi[r] * G[:, j] - psi[0] * G[:, a])
        b_ub.append(0.0)
        A_ub.append(-psi[r] * G[:, j])
        b_ub.append(-1.0)
    
    # Normalization constraint for column b: enforce sum_i G[i,b]*u_i = 1 via two inequalities
    A_ub.append(G[:, b])
    b_ub.append(1.0)
    A_ub.append(-G[:, b])
    b_ub.append(-1.0)
    
    # Constraints for each j in Y
    for j in Y:
        A_ub.append(G[:, j])
        b_ub.append(1.0)
        A_ub.append(-G[:, j])
        b_ub.append(1.0)
    
    A_ub = np.array(A_ub)
    b_ub = np.array(b_ub)
    bounds = [(None, None)] * num_vars
    
    result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
    
    if result.success:
        optimal_value = -result.fun
    else:
        if result.status == 3:  # Unbounded
            optimal_value = np.inf
        else:
            optimal_value = 0.0

    if DEBUG and (optimal_value != 0.0 or np.isinf(optimal_value)):
        print(f"DEBUG: Tuple (a={a}, b={b}, X={sorted(X)}, psi={psi}) gives objective {optimal_value:.4f}")
    
    return optimal_value

def compute_m_height(G, m):
    """
    Compute the m-height of the code generated by G.
    
    We enumerate over candidate tuples (a, b, X, psi) and return the maximum objective value.
    For a systematic matrix G = [I | P], we restrict a to identity columns and b to the P part.
    """
    k, n = G.shape
    max_value = -np.inf

    if CHECK_ALL_PAIRS:
        a_range = range(n)
        b_range = range(n)
    else:
        a_range = range(0, k)
        b_range = range(k, n)
        
    for a in a_range:
        for b in b_range:
            if a == b:
                continue
            available = set(range(n)) - {a, b}
            for X in itertools.combinations(available, m - 1):
                # Fix psi[0] = 1; iterate over remaining m-1 choices in {-1,1}
                for psi_rest in itertools.product([-1, 1], repeat=m-1):
                    psi = [1] + list(psi_rest)
                    lp_val = solve_lp_for_tuple(G, a, b, X, psi)
                    if lp_val > max_value:
                        max_value = lp_val
                    if np.isinf(lp_val):
                        return np.inf
    if max_value == -np.inf:
        return 0.0
    return max_value

def construct_generator_matrix(P):
    """
    Construct the systematic generator matrix G = [I_k | P].
    """
    k = P.shape[0]
    I_k = np.eye(k, dtype=int)
    return np.hstack((I_k, P))

def test_given_P(P, m):
    """
    Given a candidate P matrix, construct the systematic generator matrix G = [I_k | P],
    compute and print the m-height, and return the computed m-height.
    """
    print("Input candidate P matrix:")
    print(P)
    G = construct_generator_matrix(P)
    print("Constructed generator matrix G = [I | P]:")
    print(G)
    m_height = compute_m_height(G, m)
    print(f"Computed m-height for m = {m}: {m_height}")
    return m_height

if __name__ == "__main__":
    # Example: Input your own P matrix here.
    # For instance, let k = 4 and let P be a 4x(9-4)=4x5 matrix.
    # You can modify this candidate matrix as desired.
    
    P_input = np.array(
        [[ 1,  0,  0,  1,  2, -1,  1,  0],
        [ 0,  1,  0, -1,  1,  2,  0,  1],
        [ 0,  0,  1,  2,  1, -1,  1, -1]]
    )
    
    # Choose m (the m parameter for m-height computation)
    m = 3
    
    # Test the given P matrix
    test_given_P(P_input, m)