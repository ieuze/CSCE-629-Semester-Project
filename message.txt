import numpy as np
import itertools
import time
from scipy.optimize import linprog

DEBUG = False  # Set True for detailed debug prints

# --- Helper Functions (same as before) ---

def construct_generator_matrix(P):
    """
    Construct the systematic generator matrix G = [I_k | P].
    """
    k = P.shape[0]
    I_k = np.eye(k, dtype=int)
    return np.hstack((I_k, P))

def solve_lp_for_tuple(G, a, b, X, psi):
    """
    Solve the LP for a given tuple (a, b, X, psi) based on the project formulation.
    This version uses two inequality constraints to enforce the normalization constraint.
    """
    k, n = G.shape
    m = len(psi)
    
    sorted_X = sorted(X)
    if len(sorted_X) != m - 1:
        raise ValueError("Size of X must be m-1.")
    
    Y = sorted(set(range(n)) - {a, b} - set(sorted_X))
    tau = [a] + sorted_X + [b] + sorted(Y)
    tau_inv = {col: pos for pos, col in enumerate(tau)}
    
    num_vars = k
    c = - (psi[0] * G[:, a])
    
    A_ub = []
    b_ub = []
    
    for j in sorted_X:
        r = tau_inv[j]
        A_ub.append(psi[r] * G[:, j] - psi[0] * G[:, a])
        b_ub.append(0.0)
        A_ub.append(-psi[r] * G[:, j])
        b_ub.append(-1.0)
    
    A_ub.append(G[:, b])
    b_ub.append(1.0)
    A_ub.append(-G[:, b])
    b_ub.append(-1.0)
    
    for j in Y:
        A_ub.append(G[:, j])
        b_ub.append(1.0)
        A_ub.append(-G[:, j])
        b_ub.append(1.0)
    
    A_ub = np.array(A_ub)
    b_ub = np.array(b_ub)
    bounds = [(None, None)] * num_vars
    
    result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
    
    if result.success:
        optimal_value = -result.fun
    else:
        if result.status == 3:
            optimal_value = np.inf
        else:
            optimal_value = 0.0

    if DEBUG and (optimal_value != 0.0 or np.isinf(optimal_value)):
        print(f"DEBUG: Tuple (a={a}, b={b}, X={sorted(X)}, psi={psi}) gives objective {optimal_value:.4f}")
    
    return optimal_value

def compute_m_height(G, m):
    """
    Compute the m-height of the code generated by G.
    
    We enumerate over candidate tuples (a, b, X, psi) and return the maximum LP objective value.
    Here we loop over all (a, b) pairs.
    """
    k, n = G.shape
    max_value = -np.inf

    for a in range(n):
        for b in range(n):
            if a == b:
                continue
            available = set(range(n)) - {a, b}
            for X in itertools.combinations(available, m - 1):
                for psi_rest in itertools.product([-1, 1], repeat=m-1):
                    psi = [1] + list(psi_rest)
                    lp_val = solve_lp_for_tuple(G, a, b, X, psi)
                    if lp_val > max_value:
                        max_value = lp_val
                    if np.isinf(lp_val):
                        return np.inf
    if max_value == -np.inf:
        return 0.0
    return max_value

# --- Simulated Annealing Functions ---

def perturb_P(P, step_size=1):
    """
    Perturb candidate matrix P by randomly selecting an element and adding
    Â± step_size. Ensure that the resulting column is not all zeros.
    """
    P_new = P.copy()
    k, n_minus_k = P_new.shape
    i = np.random.randint(0, k)
    j = np.random.randint(0, n_minus_k)
    delta = np.random.choice([-step_size, step_size])
    P_new[i, j] += delta
    # If the column becomes all zeros, revert the change.
    if np.all(P_new[:, j] == 0):
        P_new[i, j] -= delta
    return P_new

def simulated_annealing(P_init, m, T0=100, alpha=0.95, iterations_per_temp=100, min_temp=1e-3):
    """
    Simulated annealing to minimize the m-height of the generator matrix G = [I | P].
    
    Parameters:
      P_init: initial candidate matrix P (size k x (n-k))
      m: the m parameter for m-height computation.
      T0: initial temperature.
      alpha: cooling rate.
      iterations_per_temp: number of iterations at each temperature.
      min_temp: minimum temperature before stopping.
      
    Returns: best candidate matrix P and its m-height.
    """
    P_current = P_init.copy()
    G_current = construct_generator_matrix(P_current)
    f_current = compute_m_height(G_current, m)
    P_best = P_current.copy()
    f_best = f_current
    T = T0
    iteration = 0
    print(f"Initial m-height: {f_current}")
    
    while T > min_temp:
        for _ in range(iterations_per_temp):
            P_new = perturb_P(P_current)
            G_new = construct_generator_matrix(P_new)
            f_new = compute_m_height(G_new, m)
            delta = f_new - f_current
            # Accept if the new candidate is better, or with probability exp(-delta/T)
            if delta < 0 or np.random.rand() < np.exp(-delta / T):
                P_current = P_new.copy()
                f_current = f_new
                if f_new < f_best:
                    P_best = P_new.copy()
                    f_best = f_new
                    print(f"Iteration {iteration}: New best m-height = {f_best}")
            iteration += 1
        T *= alpha
        print(f"Temperature reduced to {T:.4f}")
    return P_best, f_best

# --- Example Usage ---

if __name__ == "__main__":
    # Define parameters
    n = 9  # total number of columns in G
    k = 4  # number of rows (identity part)
    m = 2  # m parameter for m-height
    # For demonstration, initialize P with small random integers from -1 to 1.
    P_initial = np.random.randint(-1, 2, size=(k, n - k))
    # Ensure no column of P is all zero
    for j in range(P_initial.shape[1]):
        if np.all(P_initial[:, j] == 0):
            P_initial[0, j] = 1
    print("Initial candidate P:")
    print(P_initial)
    
    P_best, best_m_height = simulated_annealing(P_initial, m, T0=50, alpha=0.9, iterations_per_temp=50)
    
    print("\nSimulated Annealing Results:")
    print("Best candidate P:")
    print(P_best)
    G_best = construct_generator_matrix(P_best)
    print("Corresponding systematic generator matrix G = [I | P]:")
    print(G_best)
    print(f"Best m-height: {best_m_height}")